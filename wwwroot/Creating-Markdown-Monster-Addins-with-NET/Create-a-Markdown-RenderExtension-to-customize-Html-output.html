<!DOCTYPE html>
<html>
<head>
        <meta charset="utf-8">    
    <title>Create a Markdown RenderExtension to customize Html output - Markdown Monster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="/docs/_kavadocs/themes/scripts/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/docs/_kavadocs/themes/scripts/fontawesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/docs/_kavadocs/themes/kavadocs.css">

    <script src="/docs/_kavadocs/themes/scripts/jquery/jquery.min.js"></script>

    <script src="/docs/_kavadocs/themes/scripts/highlightjs/highlight.pack.js"></script>
    <script src="/docs/_kavadocs/themes/scripts/highlightjs-badge.min.js"></script>
    <link href="/docs/_kavadocs/themes/scripts/highlightjs/styles/vs2015.css" rel="stylesheet">

    <script src="/docs/_kavadocs/themes/scripts/ww.jquery.min.js"></script>
    <script>        
        window.page = {};
        window.page.basePath = "/docs/";      
    </script>
    <script src="/docs/_kavadocs/themes/scripts/kavadocs.js"></script>
    

    <topictype value="topic"></topictype>

    <script id="MermaidScript" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>    
        $(document).ready(function () {
            helpBuilder.initializeLayout();
            // expand all top level topics
            setTimeout(helpBuilder.tocExpandTop, 5);
        });
    </script>
    <style>
        .toc li .fa-arrow-up-right-from-square {
            font-size: 0.7em;
            color: goldenrod;
            margin-left: 0.1em;
        }
    </style>

    </head>
<body>    
    <!-- Markdown Monster Content -->
    <div class="flex-master">
        <div class="banner">

            <div class="float-start sidebar-toggle">
                <i class="fa fa-bars" title="Show or hide the topics list"></i>
            </div>
            <img src="/docs/images/logo.png" class="banner-logo">
         
            	<div class="projectname"> Markdown Monster</div>

            <div class="byline">                
                <img src="/docs/_kavadocs/icons/topic.png">
                Create a Markdown RenderExtension to customize Html output
            </div>
        </div>
        <div class="page-content">
            <div id="toc" class="sidebar-left toc-content">
                <nav class="visually-hidden">
                    <a href="/docs/tableofcontents.html">Table of Contents</a>
                </nav>
            </div>

            <div class="splitter">
            </div>

            <nav class="topic-outline">
                <div class="topic-outline-header">On this page:</div>
                <div class="topic-outline-content"></div>
            </nav>

            <div id="MainContent" class="main-content">
                <!-- Rendered Content -->
                <article class="content-pane">
                    

<h2 class="content-title">
    <img src="/docs/_kavadocs/icons/topic.png">
    Create a Markdown RenderExtension to customize Html output
</h2>




<div class="content-body" id="body">
            <p>RenderExtensions in Markdown Monster allow you to customize the HTML output that is created as part of the rendering pipeline by pre or post processing the generated markdown or html content.</p>
<p>You can do this implementing the <code>IMarkdownRenderExtension</code> interface, and adding the resulting RenderExtension to <code>RenderExtensionsManager.Current.RenderExtensions</code>.</p>
<p>This is a tree step process:</p>
<ul>
<li>Create a new Markdown Monster Addin</li>
<li>Override only the <code>OnApplicationStart()</code> method</li>
<li>Create your <code>IMarkdownRenderExtension</code> derived class implementation</li>
<li>Add your extension to the Extension Manager</li>
</ul>
<h2 id="the-imarkdownrenderextension-interface">The IMarkdownRenderExtension Interface</h2>
<p>Render Extensions work by providing pre- and post-rendering hook methods that allow you inspect and modify the incoming markdown and outgoing HTML content and are implemented via a simple <code>IMarkdownRenderExtesion</code> interface.</p>
<p>The <code>IMarkdownRenderExtension</code> interface is defined as follows (<a href="https://github.com/RickStrahl/MarkdownMonster/blob/master/MarkdownMonster/RenderExtensions/IMarkdownRenderExtension.cs">github</a>):</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Interface implemented for RenderExtensions that allow modification
/// of the inbound Markdown before rendering or outbound HTML after
/// rendering as well as any custom code that needs to be injected
/// into the document header prior to rendering.
///
/// Use the `RenderExtensionsManager.Current.RenderExtensions.Add()` to
/// add any custom extensions you create.
/// &lt;/summary&gt;
public interface IMarkdownRenderExtension
{
    void BeforeMarkdownRendered(ModifyMarkdownArguments args);
    void AfterMarkdownRendered(ModifyHtmlAndHeadersArguments args);
    void AfterDocumentRendered(ModifyHtmlArguments args);
}
</code></pre>
<h3 id="interface-members">Interface Members</h3>
<p>The interface provides 3 different hooks:</p>
<ul>
<li><p><strong>BeforeMarkdownRendered</strong><br>
Fired just before markdown is rendered into HTML. You can look at and modify the Markdown text and thus affect the render process. You also get passed the document for additional information and you have of course access to the model.<br>
<em>You can change: <code>args.Markdown</code></em></p>
</li>
<li><p><strong>AfterMarkdownRendered</strong><br>
Occurs just after the Markdown text has been rendered into an <strong>HTML Fragment</strong> of just the Markdown content. The result HTML is in <code>args.Html</code> and it's just the raw HTML fragment where the Preview template has not been applied yet: This means there's no <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code> or <code>&lt;head&gt;</code> but only the body content fragment.</p>
</li>
</ul>
<p>You can modify <code>args.Html</code> to affect rendering of the HTML. Additionally you can also set <code>args.HeadersToEmbed</code> to apply headers that are rendered into the bottom of the <code>&lt;head&gt;</code> section of the template when the template is rendered later in the pipeline. If you can modify HTML from the rendered Markdown, it's better to do it here, than in <code>AfterDocumentRendered</code> because this HTML is always refreshed.<br>
<em>You can change: <code>args.Html</code> and <code>args.HeadersToEmbed</code></em></p>
<ul>
<li><strong>AfterDocumentRendered</strong><br>
Occurs after the final HTML document has been rendered and merged with the Preview template. This is essentially the final HTML output before output is written to disk or to string for previewing as HTML. This is specific to full page output that is rendered in the preview, as well as used for PDF or HTML output generation.
<em>You can change: <code>args.Html</code></em></li>
</ul>
<p>The <code>args</code> parameter passed contains the input and output data and the updatability of the properties for each of those parameter values depends on the property's <code>readwrite</code> or <code>readonly</code> status.</p>
<h2 id="create-an-addin-and-hook-up-a-render-extension-in-onapplicationstart">Create an Addin and Hook up a Render Extension in <code>OnApplicationStart()</code></h2>
<p>In order to add a Render Extension you need to be hooked into Markdown Monster's processing pipeline and so you need to create a <a href="#__0">Markdown Monster addin</a>. The addin is going to be very simple and needs to implements only the <code>OnApplicationStart()</code> method since the addin is non-visual. Use <code>OnApplicationStart()</code> as it also allows render extensions to be fired in the MM CLI.</p>
<p>In <code>OnApplicationStart()</code> you can then hook up the Render Extension for addition into the processing pipeline.</p>
<p>Here's the entire Addin class code:</p>
<pre><code class="language-csharp">public class TestRenderExtensionAddin : MarkdownMonster.AddIns.MarkdownMonsterAddin
{
    public TestRenderExtensionAddin() : base()
    {
        Id = &quot;TestRenderExtension&quot;;    
    }

    public override async Task OnApplicationStart()
    {
        await base.OnApplicationStart();
        
        // Add the render extension
        MarkdownRenderExtensionsManager.Current.AddRenderExtension(new TestRenderExtension());
    }
}
</code></pre>
<p>Yup - it's real small, because a render extension is non-visual, so you can remove all other generated addin code and keep just this minimal <code>OnApplicationStart()</code> logic which helps minimize the impact of this addin.</p>
<h2 id="implementing-a-markdownrenderextension">Implementing a MarkdownRenderExtension</h2>
<p>Let's create a super simple and frivolous MarkdownRenderExtension that turns all occurrances of <code>the</code> in the text into a bold and upper case text using <code>**THE**</code> as the text replacement. And just for kicks lets also add a copyright notice to the bottom of the document which allows us to demonstrate both pre-processing the Markdown for the <code>THE</code> replacement and post-processing for the footer to add.</p>
<blockquote>
<p>In theory both of these transformations could be done in the same pre or post processing method - <code>BeforeMarkdownRendered()</code> being the preferred one for this scenarios since we're replacing actual Markdown text with other Markdown. I'm splitting up behavior here purely for demonstration purposes.</p>
</blockquote>
<p>To do this:</p>
<ul>
<li>Create a new <code>TestRenderExtension</code> class</li>
<li>Assign a Name to identify the extension</li>
<li>Inherit from <code>IMarkdownRenderExtension</code></li>
<li>Implement the interface - leave any unused methods empty but don't <code>throw</code></li>
</ul>
<pre><code class="language-cs">public class TestRenderExtension : IMarkdownRenderExtension
{
    public string Name { get; set; } = &quot;TestRenderExtension&quot;;

    public void BeforeMarkdownRendered(ModifyMarkdownArguments args)
    {
        var md = args.Markdown;
        md = md.Replace(&quot; the &quot;,&quot; **THE** &quot;);
        args.Markdown = md;
    }

    public void AfterMarkdownRendered(ModifyHtmlAndHeadersArguments args)
    {
        args.Html += &quot;&lt;div class='alert alert-info'&gt;&amp;copy; Test Render Extension Company&lt;/div&gt;&quot;;
    }

    public void AfterDocumentRendered(ModifyHtmlArguments args)
    { }
}
</code></pre>
<p>The result of this is that you get rendered HTML that has any individual words of the <code>the</code> show as bold, upper case <strong>THE</strong> text and a banner at the bottom of the page.</p>
<h3 id="a-note-about-script-code-refreshing-page-content-in-script-code">A Note about Script Code: Refreshing Page Content in Script Code</h3>
<p>If you inject script code into the page, realize that the script may have to be re-fired as content is refreshed. Markdown Monster doesn't re-render the entire page all the time, but rather replaces the content area with the rendered HTML content and if the script expects a page reload for updating content you need to notify or 're-run' the script code.</p>
<p>To allow script code to respond properly to this, there's an <code>previewUpdated</code> event that is fired when the document first loads and also when the preview is refreshed. So whatever initialization your script code needs, it's best to do this by handling this event.</p>
<pre><code class="language-js">$(document).on('previewUpdated',function() {
    // do something with vueJs
    var v = new Vue('#MainContent');

    // silly stuff...
    setTimeout(function() { $('pre&gt;code').css('background','darkgreen');  },3000);
});
</code></pre>
<h2 id="a-more-practical-example">A more practical example</h2>
<p>Here's a more practical example that's provided as part of Markdown Monster which is the Mermaid charting addin. Mermaid is a JavaScript library that uses specific syntax embedded in HTML to render a host of relationship charts.</p>
<p>In order to render these MM needs to:</p>
<ul>
<li>Inject the Mermaid script from CDN</li>
<li>Inject Mermaid initialization code</li>
<li>Convert <code> ```mermaid</code> into <code>&lt;div class='mermaid'&gt;</code></li>
</ul>
<p>Here's the code:</p>
<pre><code class="language-cs">/// &lt;summary&gt;
/// Handles Mermaid charts based on one of two sytnax:
///
/// * Converts ```mermaid syntax into div syntax
/// * Adds the mermaid script from CDN
/// &lt;/summary&gt;
public class MermaidRenderExtension : IMarkdownRenderExtension
{
    /// &lt;summary&gt;
    /// Add script block into the document
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
    public void AfterMarkdownRendered(ModifyHtmlAndHeadersArguments args)
    {
        if (args.Markdown.Contains(&quot; class=\&quot;mermaid\&quot;&quot;) || args.Markdown.Contains(&quot;\n```mermaid&quot;))
            args.HeadersToEmbed = MermaidHeaderScript;
    }
    
    /// &lt;summary&gt;
    /// Check for ```markdown blocks and replace them with DIV blocks
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
    public void BeforeMarkdownRendered(ModifyMarkdownArguments args)
    {
        while (true)
        {
            string extract = StringUtils.ExtractString(args.Markdown, &quot;\n```mermaid&quot;, &quot;```&quot;, returnDelimiters: true);
            if (string.IsNullOrEmpty(extract))
                break;

            string newExtract = extract.Replace(&quot;```mermaid&quot;, &quot;&lt;div class=\&quot;mermaid\&quot;&gt;&quot;)
                .Replace(&quot;```&quot;, &quot;&lt;/div&gt;&quot;);

            args.Markdown = args.Markdown.Replace(extract, newExtract);
        }
    }

    public void AfterDocumentRendered(ModifyHtmlArguments args)
    {     }



    private const string MermaidHeaderScript =
        @&quot;&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/mermaid/7.1.2/mermaid.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script&gt;
mermaid.initialize({startOnLoad:false});
...
&lt;/script&gt;&quot;;

}
</code></pre>
<p>If you need to build custom output generation functionality for Markdown Monster for creating custom syntax or simply intercepting HTML rendering output, RenderExtensions are an easy way to do this.</p>
<h2 id="managing-markdownrenderextensions-via-the-markdownextensionmanager">Managing MarkdownRenderExtensions via the MarkdownExtensionManager</h2>
<p>If for some reason you need to manage the existing Render Extensions you can use the various methods and accessors of the <code>MarkdownRenderExtensionsManager.Current</code> instance.</p>
<ul>
<li>AddRenderExtension()</li>
<li>RemoveRenderExtension()</li>
<li>GetRenderExtensions()</li>
<li>Retrieve a specific extension via the <code>[]</code> accessor</li>
</ul>
<p>These helper allow you to check and avoid dual loading of addins for example or removing functionality that might interfere with your specific use case.</p>

    </div>



                </article>

                <hr>
                <div class="float-end">
                    <a href="http://helpbuilder.west-wind.com" target="_blank"><img src="/docs/_kavadocs/images/docmonster.png" style="height: 2.5em"></a>
                </div>

                <div style="font-size: 0.75em">
                     &copy; West Wind Technologies, 2025 &bull;
                    updated: 2025-02-24
                    <br>
                                        <a href="mailto:support@west-wind.com?subject=Support: Markdown Monster - Create a Markdown RenderExtension to customize Html output&body=Project%3A%20Markdown%20Monster%0ATopic%3A%20Create%20a%20Markdown%20RenderExtension%20to%20customize%20Html%20output%0A%0AUrl%3A%0Ahttps%3A%2F%2Fmarkdownmonster.west-wind.com%2Fdocs%2F_5I30SBA89.html">Comment or report problem with topic</a>
                
                <br class="clearfix">
                <br>
                <!-- End Rendered Content -->
            </div>
        </div>
    </div>
    <!-- End Markdown Monster Content -->
</div></body>
</html>

